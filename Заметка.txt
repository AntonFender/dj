1)Установили django-2.0.7 (pip install django==2.0.7)

2)Создали проект django-admin startproject blogengine в папке app
    В папке app есть папка blogengine - это контейнер для всего нашего проекта
    В папке blogengine есть дочерняя папка blogengine - это папка с настрйками для всего нашего проекта

3)Каждый проект джанго состоит из приложений. Каждое такое приложение представляет собой некий изолированые кусок
функциональности, фитчи нашего проекта(Например: система комментариев это одно приложение, система для оплаты - это
другое приложение).У этих приложений слабая связанность, поэтому их легко можно перенести в другой проект джанго

4)Создадим приложение blog. Делается это с помощью manage.py.
python manage.py startapp blog

5)Джанго реализует патерн проектированиея MVC(Model, View, Controller)
Мы отдельно пишем код для хранения данных в БД (Model)
Отдельно пишем код для демонстрации нашего ответа пользователю(View)
Отдельно пишем код для маршрутизации запроса его обработки. Т.е до того как
мы отобразим что-то пользователю, мы должны каким то образом провести эту обработку(Controller)

6)urls.py - Отвечает за маршрутизацию запросов пользователя, которые прилетаю к нам из браузера
views.py - Отвечает за обработку этого запроса, который прилетел к нам из боаузера
models.py - Отвечает за хранение данных в БД(Можно использовать sqlLite)

7)Чтобы запустить тестовый сервер нужно выполнить команду:
manage.py runserver 5000 (Запустили сервер на 5000 порту)

8)Дожно появится предупреждение(Что есть невыполненые миграции):
    You have 14 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contentty
    pes, sessions.
    Run 'python manage.py migrate' to apply them.
Нужно выполнить:
manage.py migrate

9)Нам нужно принять запос от браузера - пользователя к определенным страницам и передать его на обработку
в функцию обработчик. Чтобы это сделать мы начинаем редактировать urls.py из папки blogengine.

10)Далее мы создали в папке blogengine файл views.py, в котором определили функцию обработчик hello

11)Приложение blog будет обрабатывать запросы, которые идут по адресу blog/
Чтобы подключить приложение blog к проекту, нужно отредактировать settings.py в папке blogengine.
Нужно добавить в список INSTALLED_APPS наше приложение blog

12)Поговорим о функции path в urls.py.
Данная функция может принимать 4 аргумента. Два аргумента позиционных(обязательные) это шаблон URL, в
данном случае "blog/"  и функция, которая будет обрабатывать запрос по URL шаблону(path('blog/', hello))
И два аргумента - это имя для данного патерна и параметры дополнительные,
которые можно передать в функция в виде словаря.

13)Можно не указывать явным образом функцию обработчика(т.е hello в патерне path('blog/', hello)).
Мы можем в качестве второго аргумента для функции path передавать другой файл urls.py, который
будет проводить более детальную маршрутизацию. Потому что у приложения blog может быть много страниц(посты, тэги и.т.д).
Для того чтобы джанго указать что более детальная маршрутизация запросов будет происходить в другом файле urls.py
в приложении - мы должны использовать функцию include(path('blog/', include('blog.urls')))

14)Чтобы создать свой html шаблон необходимо создать в приложении папку "templates/blog/".
В папке templates обязательно должна быть папка с именем приложения т.е в данном случае blog.
А уже в этой папке создаются html шаблоны.
Также стоить отметить, что django по умолчанию ищет html шаблоны в папке templates.
Поэтому можно указывать путь таким образом "blog/index.html"

15)Чтобы на запрос пользователя вернуть html шаблон нужно использовать функцию render
render(request, 'blog/index.html', context={'name': n})
В данной функции мы первым параметром указываем параметр request, вторым указываем местоположение
html шаблона а третьим параметром context можем создать словарь из ключа и значения.
Где ключ это переменная, которая может использоваться в html шаблоне.
Чтобы использовать этот ключ в шаблоне, необходимо заключить его в двойные фигурные скобки {{ name }}
Процесс наполнения шаблона данными называется рендеринг.

16)Если значением ключа выступает список и мы хотим этот список обработать, то это производиться в html шаблоне.
Чтобы обернуть каждое значение из списка в ТЭГ <p>, необходимо воспользоваться циклом. Синтаксис таков:
    {% for name in names %}
        <p>
            {{ name }}
        </p>
    {% endfor %}

17)Стоить отметить такой момент, что на каждой странице есть общие элементы(меню, сайт-бар, футор, общие подключаемые
стили css, JS файлы и.т.д. Если бы нам пришлось делать большее количество страниц и соответственно большие количество
шаблонов, то нам пришлось бы все повторяющиеся элементы, включая меню, стили, стандартные заголовки или тэг <head>
копипастить во все шаблоны. Если бы произошли изменения например в меню, то пришлось бы менять его в каждом шаблоне.
А это не есть удобно.
Для решения этой проблемы django использует такой механизм, как наследование шаблонов.
Суть его в том, что мы создаем некий базовый шаблон, который содержит общие элементы для всех страниц проекта
и который будет как бы наполняться в который впрыскиваются более частные элементы в зависимости от того
на какую страницу перешел пользователь. Создадим шаблон base_blog.html и очистим его от частностей.
Также перейдем на бутстрап https://getbootstrap.com/docs/5.0/getting-started/introduction/ и подключим
стили к нашему шаблону. После того как разабрались с общими элементами, которые будут находиться на всех страницах
в неизменяемом виде, займемся шаблонизатором django.

18)Разметим страницу местами, куда будут подставляться данные из внутренних страниц - частности.
Растановка таких мест осуществляется при помощи блоков, внутри которых размещается контент:
{% block title%}
    Block Engine
{% endblock %}

или

{% block content%}
    There is  no any content for you
{% endblock %}

19)Чтобы в html шаблоне index.html заработал наш шаблонизатор base_blog.html, нужно в шаблоне index.html
вставить в начало такую строку:
{% extends 'blog/base_blog.html' %}

20)Чтобы в index.html использовались свои данные в блоках , а не те что в base_blog.html, их нужно переопределить:
{% block title%}
    Posts list
{% endblock %}

{% block content%}
    {% for name in names %}
        <p>
            {{ name }}
        </p>
    {% endfor %}
{% endblock %}

21)Чтобы сделать так, чтобы все приложения придерживались одной стилистики, нужно сделать следущее:
1)Создать папку templates в корне проекта. Т.е в папке blogengine
2)Создадим внутри этой папке файл base.html
3)Перенесем содержимое base_block.html в base.html
4)Файл base_block.html он будет точно таким же образом, как внутренние страницы сайта расширять базовый шаблон base.html