##############   УСТАНОВКА DJANGO И СТРУКТУРА ПРОЕКТА   ##############

1)Установили django-2.0.7 (pip install django==2.0.7)

2)Создали проект django-admin startproject blogengine в папке app
    В папке app есть папка blogengine - это контейнер для всего нашего проекта
    В папке blogengine есть дочерняя папка blogengine - это папка с настрйками для всего нашего проекта

3)Каждый проект джанго состоит из приложений. Каждое такое приложение представляет собой некий изолированые кусок
функциональности, фитчи нашего проекта(Например: система комментариев это одно приложение, система для оплаты - это
другое приложение).У этих приложений слабая связанность, поэтому их легко можно перенести в другой проект джанго

4)Создадим приложение blog. Делается это с помощью manage.py.
python manage.py startapp blog

##############   РОУТИНГ ЗАПРОСОВ   ##############

5)Джанго реализует патерн проектированиея MVC(Model, View, Controller)
Мы отдельно пишем код для хранения данных в БД (Model)
Отдельно пишем код для демонстрации нашего ответа пользователю(View)
Отдельно пишем код для маршрутизации запроса его обработки. Т.е до того как
мы отобразим что-то пользователю, мы должны каким то образом провести эту обработку(Controller)

6)urls.py - Отвечает за маршрутизацию запросов пользователя, которые прилетаю к нам из браузера
views.py - Отвечает за обработку этого запроса, который прилетел к нам из боаузера
models.py - Отвечает за хранение данных в БД(Можно использовать sqlLite)

7)Чтобы запустить тестовый сервер нужно выполнить команду:
manage.py runserver 5000 (Запустили сервер на 5000 порту)

8)Дожно появится предупреждение(Что есть невыполненые миграции):
    You have 14 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contentty
    pes, sessions.
    Run 'python manage.py migrate' to apply them.
Нужно выполнить:
manage.py migrate

9)Нам нужно принять запос от браузера - пользователя к определенным страницам и передать его на обработку
в функцию обработчик. Чтобы это сделать мы начинаем редактировать urls.py из папки blogengine.

10)Далее мы создали в папке blogengine файл views.py, в котором определили функцию обработчик hello

11)Приложение blog будет обрабатывать запросы, которые идут по адресу blog/
Чтобы подключить приложение blog к проекту, нужно отредактировать settings.py в папке blogengine.
Нужно добавить в список INSTALLED_APPS наше приложение blog

12)Поговорим о функции path в urls.py.
Данная функция может принимать 4 аргумента. Два аргумента позиционных(обязательные) это шаблон URL, в
данном случае "blog/"  и функция, которая будет обрабатывать запрос по URL шаблону(path('blog/', hello))
И два аргумента - это имя для данного патерна и параметры дополнительные,
которые можно передать в функция в виде словаря.

13)Можно не указывать явным образом функцию обработчика(т.е hello в патерне path('blog/', hello)).
Мы можем в качестве второго аргумента для функции path передавать другой файл urls.py, который
будет проводить более детальную маршрутизацию. Потому что у приложения blog может быть много страниц(посты, тэги и.т.д).
Для того чтобы джанго указать что более детальная маршрутизация запросов будет происходить в другом файле urls.py
в приложении - мы должны использовать функцию include(path('blog/', include('blog.urls')))

##############   ШАБЛОНЫ И НАСЛЕДОВАНИЕ ШАБЛОНОВ   ##############

14)Чтобы создать свой html шаблон необходимо создать в приложении папку "templates/blog/".
В папке templates обязательно должна быть папка с именем приложения т.е в данном случае blog.
А уже в этой папке создаются html шаблоны.
Также стоить отметить, что django по умолчанию ищет html шаблоны в папке templates.
Поэтому можно указывать путь таким образом "blog/index.html"

15)Чтобы на запрос пользователя вернуть html шаблон нужно использовать функцию render
render(request, 'blog/index.html', context={'name': n})
В данной функции мы первым параметром указываем параметр request, вторым указываем местоположение
html шаблона а третьим параметром context можем создать словарь из ключа и значения.
Где ключ это переменная, которая может использоваться в html шаблоне.
Чтобы использовать этот ключ в шаблоне, необходимо заключить его в двойные фигурные скобки {{ name }}
Процесс наполнения шаблона данными называется рендеринг.

16)Если значением ключа выступает список и мы хотим этот список обработать, то это производиться в html шаблоне.
Чтобы обернуть каждое значение из списка в ТЭГ <p>, необходимо воспользоваться циклом. Синтаксис таков:
    {% for name in names %}
        <p>
            {{ name }}
        </p>
    {% endfor %}

17)Стоить отметить такой момент, что на каждой странице есть общие элементы(меню, сайт-бар, футор, общие подключаемые
стили css, JS файлы и.т.д. Если бы нам пришлось делать большее количество страниц и соответственно большие количество
шаблонов, то нам пришлось бы все повторяющиеся элементы, включая меню, стили, стандартные заголовки или тэг <head>
копипастить во все шаблоны. Если бы произошли изменения например в меню, то пришлось бы менять его в каждом шаблоне.
А это не есть удобно.
Для решения этой проблемы django использует такой механизм, как наследование шаблонов.
Суть его в том, что мы создаем некий базовый шаблон, который содержит общие элементы для всех страниц проекта
и который будет как бы наполняться в который впрыскиваются более частные элементы в зависимости от того
на какую страницу перешел пользователь. Создадим шаблон base_blog.html и очистим его от частностей.
Также перейдем на бутстрап https://getbootstrap.com/docs/5.0/getting-started/introduction/ и подключим
стили к нашему шаблону. После того как разабрались с общими элементами, которые будут находиться на всех страницах
в неизменяемом виде, займемся шаблонизатором django.

18)Разметим страницу местами, куда будут подставляться данные из внутренних страниц - частности.
Растановка таких мест осуществляется при помощи блоков, внутри которых размещается контент:
{% block title%}
    Block Engine
{% endblock %}

или

{% block content%}
    There is  no any content for you
{% endblock %}

19)Чтобы в html шаблоне index.html заработал наш шаблонизатор base_blog.html, нужно в шаблоне index.html
вставить в начало такую строку:
{% extends 'blog/base_blog.html' %}

20)Чтобы в index.html использовались свои данные в блоках , а не те что в base_blog.html, их нужно переопределить:
{% block title%}
    Posts list
{% endblock %}

{% block content%}
    {% for name in names %}
        <p>
            {{ name }}
        </p>
    {% endfor %}
{% endblock %}

21)Чтобы сделать так, чтобы все приложения придерживались одной стилистики, нужно сделать следущее:
1)Создать папку templates в корне проекта. Т.е в папке blogengine
2)Создадим внутри этой папке файл base.html
3)Перенесем содержимое base_block.html в base.html
4)Файл base_block.html он будет точно таким же образом, как внутренние страницы сайта расширять базовый шаблон base.html
Для этого сотрем все содержимое в base_block.html и добави туда запись:
{% extends "base.html" %}
5)Чтобы все это заработало, нужно в настрйках проекта setting.py подключить все это дело
Нужно в переменную TEMPLATES в список DIRS добавить такую строку:
os.path.join(BASE_DIR, 'templates')
Где BASE_DIR - это абсолютный путь до нашего проекта.


##############   БАЗЫ ДАННЫХ   ##############

Поговорим о хранении данных в базе данных о чтении данных изменении и отображении этих данных
в шаблоны. По умолчанию мы будем использовать sqlite3

1)Чтобы создать модель Post переходим в blog/models.py
2)После того, как мы заполнили models.py переходим в директорию с проектом, где лежит
manage.py. Чтобы внести изменения в БД из файла models.py нужно выполнить слежущие команды:
    1)Создадим файлы миграций - manage.py makemigrations
    2)Применим файлы миграций к БД - manage.py migrate
    3)Готова
    4)Можно перейти в консоль Джаги и поиграться с нашей моделью - manage.py shell

        from blog.models import Post
        p = Post(title='New post', slug='new-slug', body='New post body')
        p.save()
        Чтобы посмотреть записи (p.id, p.body)

        Можно так добавить, тогда не нужно вызывать метод save:
        p1 = Post.objects.create(title='new post2', slug='new-slug2', body='body2')

        У метода objects есть много методов для работы с получением информации из БД.
        Нужно их смотреть в документации.

3)Воспроизведем все что записали в БД во views.py:
posts = Post.objects.all()
return render(request, 'blog/index.html', context={'posts': posts})
Тут мы получили все записи из БД и передали ключю posts

4)Далее мы изменили index.py . Добавили стилей и циклом отобразили содержимое БД.
Также мы указали фильтр truncatewords:15. Он обрезает слова до 15 символов.
Все фильтры можно посмотреть в документации джанго

5)Далее мы изменили базовый шаблон base.html в котором поменяли имя меня с home на blog и указали ссылку
<a class="nav-link active" aria-current="page" href="{% url 'posts_list_url' %}">Blog</a>
В данной ссылке {% url 'posts_list_url' %}, значение posts_list_url задается в файле urls.py в таком виде:
path('', posts_list, name='posts_list_url')
Т.е мы дали имя нашему маршруту. Это удобно, если мы захотим изменить наш маршрут

6)Сделаем внутренние страницы, отображающие содержание поста.
Подставим в кнопку Read ссылку на соответствующую страницу поста для каждого поста
Для того чтобы попасть на страницу с постом нам нужно в начале идентифицировать конкретный пост
среди всех остальных. Изначально идентификация объектов в базе осуществляется по id.
Но обычно людям нравится, когда они переходят по ссылкам по которым они изначально могут оценить содержание.
Для этого используется ЧПУ(человеко-понятные урлы). Для постов эту функцию выполняет slug.
Поэтому поле slug мы определяли уникальным, чтобы мы могли идентифицировать конкретный объект по этому слагу

    1)Отредактируем urls.py. Создадим новый маршрут:
        path('post/<str:slug>/', post_detail, name='post_detail_url')
        <> - означает, что те символы, которые идут после слова post/ , это именованная группа символов
        и мы должны присвоить этой именовоной группе символов собстенное имя(slug).
        По умолчанию эта именованая группа относится к типу string, поэтому мы явно это зададим(str)
    2)Далее переходим в файл views.py и создаем метод def post_detail(request, slug). Коментарии там есть.
    3)Создаем файл post_detail.html и заполняем его по стандартному принципу
    4)Далее переходим в файл index.html назначаем путь на кнопу:
        <a href="{% url 'post_detail_url' slug=post.slug %}" class="btn btn-light">Read</a>
        Но такой подход не очень удобен, когда разрастеться наш сайт, такое использование будет проблемотично
        Для этого перейдем в файл models.py и создадим там метод get_absolute_url(self)
        Данный метод будет возвращать ссылку на конкретный объект(на конкретный экземляр класса Post)
        Для этого мы импортируем метод reverse - from django.shortcuts import reverse.
        Функция reverse будет генерировать нам ссылку.
        И в файле index.html запись приобретет другой вид:
            <a href="{{ post.get_absolute_url }}" class="btn btn-light">Read</a>

##############   Создание модели Tag, отношения ManyToMany, includes   ##############

1) Сделаем теги. Т.е пометим посты определенными метками. Задача тегов заключается в создании классификации
или категоризации наших постов. Т. е с помощью тегов мы объеденяем наши посты в группы по определенным тэгам.
Это работает так, что пользователь увидел тэг, кликнул по нему и ему открылась страница со всеми постами
, которые ассоциырованы с этим тэгом. Такая ассоциация или связь между двумя моделями называется
many-to-many.

2)Создадим еще одну модель в файле models.py с название Tag и создадим два поля title и slug
3) Теперь нам нужно установить связь между мелелью Post и Tag. Для этого мы где-нибудь в моделе Post
(Можно сделать и в моделе Tag), создаем новое свойство(tags):
    tags = models.ManyToManyField('Tag', blank=True, related_name='posts')
        Tag - это название класса с которой устонавливаем связь
        blank - Сделаем чтобы свойство tags не было обязательным для наших постов
        related_name - обозначает то свойство, которое появиться соответственно у экземляра класса Tag
4)Далее создаим файл миграции и произведем миграцию. После этого мы в через shell добавили один тэг
Tag.objects.create(title='dj', slug='dj')
5)Далее заходим в файл ursl.py приложения blog и пишем такой путь:
    path('tags/', tags_list, name='tags_list_url')
6)Далее создаем html шаблоны и.т.д

##############   Уроки Django 2 - Class Based Views (CBVs) и использование Миксинов   ##############


1)По умолчанию наши функции обработчики в файле views.html обрабатыват только get запросы
т.е только запросы на чтение. Запросы на запись данных в БД(POST запросы), когда мы что-то предаем на сервер
, также другие запросы типо PUT, DELETE и.т.д. Наши функции обработчки, в том виде в котором мы их описали,
они их обрабатывать не могут. Это не единственная проблема.
Также есть проблема избыточности кода. У нас есть много практически одинаковых функций обработчиков.
В джанго есть специальный класс Views , с помощью которого достаточно удоно обрабатывать разные
http запросы. Также есть механизм наслеования с помощью которого можно решить вопрос избыточности кода.

2)Перепишем в классы функции post_detail и tag_detail в файле views.py
Говорить об этом нечего. Единственное нужно переопределять метод get. Если использовать свое имя
то работать не будет. А также в urls.py необходимо указать функцию обраюотчик по другому
PostDetail.as_view()
TagDetail.as_view()

3)Также в данных классах можно возвращать ошибки 404 и.т.д ,если перешли не на ту страницу
Это делается также в классе views.py таким образом tag = get_object_or_404(Tag, slug__iexact=slug).
Заранее нужно импортировать библиотеку  from django.shortcuts import get_object_or_404

4)Чтобы избавится от избыточности кода создается специальный класс с общим для тех класов, которые
можно объеденить, поведением. Такие классы называются миксинами(примисями).
Чтобы использовать миксины создадим в нашем приложении blog новый файл utils.py
В нем будет класс, описывающий поведение двух других класов.
В файле views.py , ном нужно будет только лишь переопределить объекты наследуемого класса и все.

##############   Работа с формами Form, ModelForm, валидация данных    ##############

1)Создадим в корне приложения файл forms.py и создадим там нашу форму
2)Короче очко это все описывать. Нужно запоминать и практиковаться.



